# CS-305-Module-8-Journal

## The Client
Artemis Financial is a consulting company in the realm of financial services. They provide consultation for the development of individualized financial plans for their customers. This can mean savings strategies, retirement vehicles, investment vehicles and strategies as well as insurance. They feel that their operations are not modern enough and wish to use a custom software solution for  their customers to interface with. Since financial information will be handled, it is of the utmost concern that current and effective security solutions are used in the production of their solution. Their primary concern was to perform data verification in the form of a checksum output. 

## The Security
Software security adds liability protection to a client which is a large value add to the company's overall wellbeing. If the customer implemented a solution that wasn't secure and their customer's data became compromised, the company would certainly be held legally liable. Not only would their customers be damaged, but the company could be led into bankruptcy as a result of lawsuits and damaged reputation in the industry. Maintaing the highest security standards is maintaining the lifeline of the company, because without the ability to guarantee some level of privacy and security, no financial consulting company would able to do enough business to become successful. That is why the software vulnerability assesment diagram is useful, it provides a pathway for assessing what areas of a given application should be focused on the most. In an ideal situation, every single node would be heavily inspected in the application to ensure a completely secure solution, but in a world of compressed schedules and limited resources it can be useful to help identify the most critical points to be addressed.

## The Implementation 
We were able to increase layers of security by adding layers of verification methods. We initially used the SHA-256 hashing algorithm to ensure that we can encrypt data moving in through the interface. This means that anyone who performs a man in the middle attack is rendered a jumble of letters that mean absolutely nothing and would take until all life expires on earth to reverse or break. The second layer was a checksum verification, which allows a user to verify that our data is being encrypted, and that it changes when the data changes which is a function that our checksum is also working. Since the hash itself cannot be reversed, displaying a checksum is a great visual verification layer. Then we added our final layer by requiring secure access to the application server. This means we can instruct customers to only make secure connections, which they can verify by checking the certificate of the page. If the certificate is not present or different in any way then it serves as a visual verification that something is awry. I believe it is important the verification methods are visual as well. In the future, I would strive to implement as many visual verifications of a functioning, or non functioning security system so that the customer is able to feel confident about their interactions with the application. 

## The Verification
I ensured that my implementations were functional by testing them. Since the provided security layers were intended to output methods for visual verification, I used them as intended to verify they are secure. I input data and then verified my checksum output. In order to verify that the algorithm was working appropriately, I then made a small change to the input data and reloaded the application to verify the significant change in the new checksum output. This showed me that the avalanche affect was in full swing and that no pattern could be established in between the hash values and the original data. After refactoring my code to require a secure HTTP request, I verified it by attempting to open the application with a standard HTTP request and seeing that I was unable to to. After opening it, I verified the contents of the certificate used on the application against the data I input to create the certificate and its keystore file. I also used the OWASP dependency checker to verify that as I was adding code in and making changes to my encryption algorithms being used, that I was not adding any new vulnerabilities. I was able to identify that we had several vulnerbalities in the project due to module versions that came with the project, but nothing new was added through the addition of my code. I was also able to verify that any warnings I had in my IDE were not related to issues in my code, and the terminal output when running the server didn't provide any troubling messages. The most useful resource in this domain was Youtube. I had found several videos that discussed keystore files and certification for web applications which helped me gain a better understanding of why they are used in the first place. 

## The Future
I believe this assignment will show future employers that I aware of the importance of security in any project. It is something that shouldn't be an afterthought but a core component of the system design. It would also show future employers that I wouldn't let my personal pride get in the way of security and quality. I do not imagine that I could possibly know more on my own than teams of security analysts and researchers that are constantly working on new algorithms and libraries to support secure application development, and I would sooner use a proven and well known industry solution than attempt to develop my own solution simply for the sake of recognition. I also believe this shows my ability to learn. I am ending this class believing to be an expert in security. I am ending this class realizing how large the world of software security is, and that I am able to dip into that world and learn what I need to in order to complete a task. 
